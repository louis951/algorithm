#include <iostream>
#include <vector>
#include <algorithm>
#include <list>
#include <iomanip>      // for setw()

struct Edge {
	int from, to, weight;
	Edge() {};
	Edge(int u, int v, int w) :from(u), to(v), weight(w) {};
};

class GraphMST {
private:
	int num_vertex;
	std::vector<std::vector<int>> AdjMatrix;
public:
	GraphMST() :num_vertex(0) {};
	GraphMST(int n) {
		this->num_vertex = n;
		AdjMatrix.resize(num_vertex);
		for (int i = 0; i < num_vertex; i++) {
			AdjMatrix[i].resize(num_vertex);
		}
	}
	void AddEdge(int from, int to, int weight);

	void KruskalMST();
	void GetSortedEdge(std::vector<struct Edge> &vec);
	friend int FindSetCollapsing(int *subset, int i);
	friend void UnionSet(int *subset, int x, int y);
};
int FindSetCollapsing(int *subset, int i) {      // 用遞迴做collapsing

	int root;  // root
	for (root = i; subset[root] >= 0; root = subset[root]);

	while (i != root) {
		int parent = subset[i];
		subset[i] = root;
		i = parent;
	}

	return root;
}
void UnionSet(int *subset, int x, int y) {

	int xroot = FindSetCollapsing(subset, x),
		yroot = FindSetCollapsing(subset, y);

	// 用rank比較, 負越多表示set越多element, 所以是值比較小的element比較多
	// xroot, yroot的subset[]一定都是負值
	if (subset[xroot] <= subset[yroot]) {        // x比較多element或是一樣多的時候, 以x作為root
		subset[xroot] += subset[yroot];
		subset[yroot] = xroot;
	}
	else {    //  if (subset[xroot] > subset[yroot]), 表示y比較多element
		subset[yroot] += subset[xroot];
		subset[xroot] = yroot;
	}
}
bool WeightComp(struct Edge e1, struct Edge e2) {
	return (e1.weight < e2.weight);
}
void GraphMST::GetSortedEdge(std::vector<struct Edge> &edgearray) {

	for (int i = 0; i < num_vertex - 1; i++) {
		for (int j = i + 1; j < num_vertex; j++) {
			if (AdjMatrix[i][j] != 0) {
				edgearray.push_back(Edge(i, j, AdjMatrix[i][j]));
			}
		}
	}
	// 用std::sort 排序, 自己定義一個comparison
	std::sort(edgearray.begin(), edgearray.end(), WeightComp);
}
void GraphMST::KruskalMST() {

	struct Edge *edgesetMST = new struct Edge[num_vertex - 1];
	int edgesetcount = 0;

	int *subset = new int[num_vertex];
	for (int i = 0; i < num_vertex; i++) {
		subset[i] = -1;
	}

	std::vector<struct Edge> increaseWeight;
	GetSortedEdge(increaseWeight);              // 得到排好序的edge的vec

	for (int i = 0; i < increaseWeight.size(); i++) {
		if (FindSetCollapsing(subset, increaseWeight[i].from) != FindSetCollapsing(subset, increaseWeight[i].to)) {
			edgesetMST[edgesetcount++] = increaseWeight[i];
			UnionSet(subset, increaseWeight[i].from, increaseWeight[i].to);
		}
	}
	// 以下僅僅是印出vertex與vertex之predecessor
	for (int i = 0; i < num_vertex - 2; i++)
		std::cout << edgesetMST[i].from << " " << edgesetMST[i].to << "\n";
	
}
void GraphMST::AddEdge(int from, int to, int weight) {
	AdjMatrix[from][to] = weight;
}

int main() {

	int V, E;
	std::cin >> V >> E;
	GraphMST g6(++V);
	int u, v, w;
	for (int i = 0; i < E; i++) {
		std::cin >> u >> v >> w;
		g6.AddEdge(u, v, w);
	}

	g6.KruskalMST();

	return 0;
}
